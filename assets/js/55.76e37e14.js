(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{461:function(t,s,v){"use strict";v.r(s);var _=v(2),a=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"算法思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法思想"}},[t._v("#")]),t._v(" 算法思想")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("算法思想是解决算法问题的核心")])]),t._v(" "),s("ol",[s("li",[t._v("递归")])]),t._v(" "),s("p",[t._v("概念: 通过重复将问题分解为同类的子问题而解决问题的一种方法.")]),t._v(" "),s("p",[t._v("形式: 直接或间接调用自身的函数")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("分治")])]),t._v(" "),s("p",[t._v("概念: 将一个规模为 N 的问题分解为 K 个规模较小的子问题, 求出子问题的解就可得到原问题的解.")]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("贪心")])]),t._v(" "),s("p",[t._v("概念: 在对问题求解时, 做出在当前看来最优的选择, 也就是局部最优解.")]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[t._v("回溯")])]),t._v(" "),s("p",[t._v('概念: 在搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就"回溯"返回,尝试别的路径.')]),t._v(" "),s("ol",{attrs:{start:"5"}},[s("li",[t._v("动态规划")])]),t._v(" "),s("p",[t._v("概念: 将复杂问题分解成小问题求解的策略, 与分治算法不同的是, 分治算法要求各子问题是相互独立的, 而动态规划各子问题是相互关联的.")]),t._v(" "),s("ol",{attrs:{start:"6"}},[s("li",[t._v("枚举")])]),t._v(" "),s("p",[t._v("概念: 枚举所有的可能, 尽可能地尝试所有的方法.")])])}),[],!1,null,null,null);s.default=a.exports}}]);